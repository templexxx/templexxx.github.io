<html>
    <head>
        <meta http-equiv="content-type" content="text/html; charset=utf-8" />
        <link href="http://www.templex.xyz/main.css" rel="stylesheet" type="text/css">
        <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed">
        <link rel="shortcut icon" href="http://www.templex.xyz/images/3x3.jpg">
        <title>ReedSolomon in Golang</title>
</head>
<body>
    <h2>ReedSolomon</h2>
    <h3>为什么要造轮子？</h3>
    <p>Reed-Solomon codes已经问世50余年了，是门非常成熟的并且应用广泛的技术。</p>
    <p>在优化方面，公认的最佳做法就是利用SIMD技术加速(具体的方法我随后展开)。看上去其并不适宜重新造轮子，而且新轮子极大可能远远不如老轮子。</p>
    <p>我的初衷是通过这个过程学习一下群，域，矩阵等数学知识以及它们在计算机上的应用。在阅读一些著名的开源库的时候，我发现有一些疑问很多人都有，但
        大家似乎都没有很好的回答过，似乎这些问题非常的高深。这让我觉得很不应该，我本能的认为这些问题应该没那么难。于是在解决这些问题的过程中，我写完了这个库。</p>
    <h3>站在巨人的肩膀上</h3>
    <p>最早接触的是Jerasure的实现以及一些科普性的文章，那个时候连hello world都不会写，只留下了粗浅的印象。</p>
    <p>后来逐渐发现了更多的开源库,其中:<a href="https://github.com/klauspost/reedsolomon">Klauspost</a>参考<a href="https://github.com/Backblaze/JavaReedSolomon/">Backblaze</a>而实现。
    而我又参考着klauspost的实现。</p>
    <p>我主要参考了其汇编实现，然而原先的代码受限于go早期版本支持的指令有限，因此代码中很多字节码。另外注释有些不清晰，
        我加上了一些关于指令执行过程的说明，这样对于使用者来说更友好。</p>
    <h3>工作原理</h3>
    <p>我这里并不试图展开细节，一方面事无巨细的介绍容易没有终点，二是因为涉及的知识点着实太多，每一门知识又有其必要的基础知识，这要求
    必须根据读者的水平阐述，在一篇文章中要做到这点是非常困难的。</p>
    <p>同时我又觉得我不能跳过数学原理的介绍。网络上的相关介绍要么太过简略，要么是一门非常系统的课程，
        总之少有人去引导整个过程的学习。所谓“授人以鱼不如授人以渔”，我便分享一下我的学习过程吧。</p>
    <p>首先，我们得对群这个概念和性质有基本的认识，这里我推荐台湾国立交通大学的化学应用群论这门公开课。其中有两节课是纯粹讲群的和化学无关，我觉得老师
    很有耐心，每一步的步骤非常清楚。这个时候我们已经能手工写一些order非常小的域了，我建议是自己列一列加法表和乘法表以增强印象。</p>
    <p>接下来可以阅读<<代数编码与密码>>这本书关于多项式的理论，学习如何通过多项式构建有限域。可以手算结果，然后上<a href="http://www.ee.unb.ca/cgi-bin/tervo/calc2.pl">UNB</a>
    验证结果。另外在我的代码<a href="https://github.com/templexxx/reedsolomon/blob/master/tools/gentables.go">gentables.go</a>中也可以学习生成本原多项式以及生成表的过程。</p>
    <p>我们还需要知道矩阵运算的基本常识，基本上掌握矩阵的乘法，矩阵求逆就足以应付了。我在这里推荐<<程序员的数学:线性代数>>这一书，尤其需要注意的
    知识点是Gauss-Jordan方法，这一方法也是目前代码中用来求逆矩阵的方法（由于我们使用的矩阵比较特殊，个人觉得求逆还可以再优化）</p>
    <p>有了矩阵的基础，我们对选择编码矩阵也有了基本的认识。我在代码中使用的是Cauchy matrix,生成的算法参考了Intel的ISA-L库。我也有提到我们不能直接
    使用Vandermonde matrix，具体的原因我有在互联网世界的某一个角落的中提到。不过我认为如果掌握了上面的知识，大家也可以得到这个结论。</p>
    <p>数学的部分基本讲完了，还有一点数学知识是和优化相关的。其实非常的简单而优雅，寥寥几句就可以阐明核心,
    但我还是推荐大家读一下论文<a href="http://www.kaymgee.com/Kevin_Greenan/Publications_files/plank-fast2013.pdf">Screaming Fast Galois Field Arithmetic Using Intel SIMD Instructions</a></p>
    <p>其加速的原理就是讲一个byte以4bit为界限拆分成左右两个部分，每一个部分的乘法表只有16byte的长度，正好可以塞进XMM寄存器里。对于YMM寄存器，我们则可以塞两张表进去。</p>
    <p>利用CPU提供的指令，以数据为MASK，对表进行重新排序，然后异或左右两个部分的值我们就得到了编码后的结果了。</p>
    <h3>Performance</h3>
    <p>代码在这里：<a href="https://github.com/templexxx/reedsolomon">templexxx</a></p>
    <p>无论编码还是解码，其性能都是非常强劲的。在我同事的笔记本(i7-6700HQ)上对256KB大小的数据块做10x4的encode速度超过了20GB/S</p>
    <p>知名的性能优秀的库在编码上（也就是库中汇编代码的工作）的优化方式都是一样的，其区别主要是在并发控制，以及并发的块大小</p>
    <p>根据我的经验，并发的管道和物理核心数保持一致，并发块与L1 DATA一般尺寸表现会非常好 </p>
    </body>
    </html>
