<html>
    <head>
        <meta http-equiv="content-type" content="text/html; charset=utf-8" />
        <link href="http://www.templex.xyz/main.css" rel="stylesheet" type="text/css">
        <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed">
        <link rel="shortcut icon" href="http://www.templex.xyz/images/3x3.jpg">
        <title>使用SIMD为Golang加速</title>
</head>
<body>
    <h2>使用SIMD为Golang加速</h2>

    <h3>汇编的门槛</h3>
    <p>失去重重抽象的庇护，汇编看上去非常的丑陋。用汇编来编写大型程序简直难以想象，不过在这里，我们仅仅使用汇编来进行AMD64体系下的运算加速，这并不会特别困难。</p>
    <p>Golang有自己的汇编语法，总体上是AT&T风格，即:</p>
    <p>< opcode source destination ></p>
    <p>以上就是汇编里你能用到的最复杂的语句形式了。汇编的简单性就在这里，只要你明确了你所需要的指令，数据源以及存储的位置，你就可以写出正确的代码。</p>

    <h3>寄存器</h3>
    <p>Golang对寄存器做了一层封装，个人认为使用起来还是比较便捷的。</p>
    <p>这里是Golang自己的文档，写的非常简略，但针对伪寄存器的说明已经足够了：<a href="https://golang.org/doc/asm">godoc</a></p>
    <p>通用寄存器分别是AX BX CX DX SI DI BP SP R8-R15。</p>
    <p>64位下128bit寄存器为X0-X15,256bit寄存器为Y0-Y15。</p>

    <h3>SIMD</h3>
    <p>这里有一份不错的代码示例：<a href="https://goroutines.com/asm">simd_example</a></p>
    <p>我借它来进行一些补充说明：</p>
    <ol>
    <li>它这里没使用AVX而使用SSE，主要原因我认为是Golang不识别某些AVX指令</li>
    <li>使用NOSPILT这个flag，需要在文件头部加入：<code>#include "textflag.h"</code>,或者直接填4</li>
    <li>末尾的SFENCE指令，其作用是确保数据全部写进了内存</li>
    <li>调用这个汇编函数的函数代码:<code>func Multiply(data []V4, m M4)</code>
    这个函数没有body。随后就可以再外部调用它了</li>
    </ol>

    </body>
    </html>
