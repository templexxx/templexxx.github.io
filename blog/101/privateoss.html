<html>
    <head>
        <meta http-equiv="content-type" content="text/html; charset=utf-8" />
        <link href="http://www.templex.xyz/main.css" rel="stylesheet" type="text/css">
        <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed">
        <link rel="shortcut icon" href="http://www.templex.xyz/images/3x3.jpg">
        <title>UGC私有云存储的设计与代码（一）</title>
</head>
<body>
    <h2>UGC私有云存储之设计与代码（一）</h2>
    <p>只有我有简单提到对象存储的设计的一些坑，
        <a href="http://www.templex.xyz/blog-cn/101/replication_repair.html">(设计高可靠的存储系统)</a>
        但有些形而上，这次我讲撸起袖子干点“脏活”。</p>
    <p>首先我得讲讲为什么我们既不用现成的公有云或者私有云解决方案甚至开源解决方案，要自己造轮子</p>
    <ol>
    <li>降低成本</li>
    <p>通通按三副本算，公有云并不便宜，反倒挺贵。如果是大厂的私有云也不便宜</p>
    <li>提高性能</li>
    <p>针对自己的业务场景可以定制优化</p>
    <li>不放心服务商的良心和技术</li>
    <p>企业存储领域的老大从06年开始做对象存储，到现在依然有令人不满意的地方。
        就别提其他号称领先的存储供应商了
    </p>
    <li>原有架构以及人员配置</li>
    <p>寡人兵多将多，当然不会花钱再搞雇佣军。况且我哪些陪我出深入死的兄弟怎么办？都解散了不成？
    </p>
    </ol>
    <p>还有诸多因素我就不一一列举了，反正铁了心我们要自己搞一套</p>
    <h3>小文件存储</h3>
    <p>小文件可以说是最头疼的。可以想象，如果一个文件一块盘，总共1000块盘，也没啥人访问。
        我只要做好数据保护就行了。但如果换成1PB的10KB小文件又有老多人访问，情况就大大不同了。</p>
    <p>最直接问题主要有两个:</p>
    <ol>
    <li>索引负担重</li>
    <li>随机IO跟不上</li>
    </ol>
    <p>我们先来讲讲随机IO，相这种由于“生产者”和“消费者”能力不匹配的最直接的解决办法就是引入缓存层。
        这里我要夸奖一下B站的设计，他们的多级缓存一方面进一步减少源站压力，另外一方面还可以提高可用性。
        </p>
    <p>除了引入缓存，我们还可以提高存储介质的物理性能。由于存储是为自己服务，很容易获得文件大小分布的信息，
        以此为依据设定SSD集群的“准入条件”，比如30KB,40KB等等。<p>
    <p>为了减轻索引层面的负担，最直接的做法是对文件进行合并，或者直接甩到数据库里存起来。
    </p>
    <p>存在数据库里的利弊都比较明显，也不是本文重点，我也不讲了。<p>
    <h3>修复</h3>
    <p>修复速度的提高从两个方面入手：</p>
    <ol>
    <li>减少修复所需的数据量</li>
    <li>增加参与修复的磁盘数量</li>
    </ol>
    <p>第一点主要针对于EC，其中Facebook Azure都使用了改良版本的RS codes。
    </p>
    <p>第二点指的是并行修复。并行修复主要是为了应对单盘外部IO的瓶颈，但同时给了数据库和内部网络更大的压力。
        尤其是数据库的压力可能直接导致“丢数据”。所以我不建议并行修复的scope直接指定为全局。
    </p>
    <h3>向左走向右走</h3>
    <p>不难发现，设计高可靠的存储系统基本是在诸多成熟方案中做出选择，最终的可靠性取决于这套组合拳的配合程度。
        虽然这里仅有寥寥几百字，但都是很多光鲜亮丽的公司在这上面栽过的跟头
    </p>
        </body>
    </html>